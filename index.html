<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas! ğŸ„</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; user-select: none; }
        
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-family: 'Great Vibes', cursive; font-size: 60px;
            background: linear-gradient(to bottom, #fffebd, #ffd700); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px #ffaa00);
            pointer-events: none; z-index: 10;
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #music-btn {
            position: absolute; bottom: 30px; right: 30px; z-index: 20;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; border-radius: 30px; cursor: pointer;
            font-family: sans-serif; font-size: 14px; backdrop-filter: blur(5px); transition: 0.3s;
        }
        #music-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        
        /* åŠ è½½é®ç½© */
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #000; color: #ffd700; display: flex;
            justify-content: center; align-items: center; font-family: sans-serif;
            z-index: 999; transition: opacity 1s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">æ­£åœ¨ç§æ¤åœ£è¯æ ‘...</div>
    <div id="info">Merry Christmas & Happy New Year</div>
    <button id="music-btn">ğŸµ Play Music</button>
    <audio id="bgm" loop><source src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/win.ogg" type="audio/ogg"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        // å¼•å…¥åæœŸå¤„ç†æ ¸å¿ƒåº“ (è®©ç”»é¢å‘å…‰)
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- åŸºç¡€è®¾ç½® ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.02); // æ·±å¤œé›¾æ°”

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 4, 12); // ç›¸æœºç¦»å¾—ç¨è¿œä¸€ç‚¹çœ‹å…¨æ™¯

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true; // å¼€å¯é˜´å½±
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // æŸ”å’Œé˜´å½±
        renderer.toneMapping = THREE.ReinhardToneMapping; // ç”µå½±æ„Ÿè‰²è°ƒ
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // ç¦æ­¢é’»åˆ°åœ°ä¸‹

        // --- åä¸½çš„æ ¸å¿ƒï¼šåæœŸå¤„ç† (Bloom Effect) ---
        const renderScene = new RenderPass(scene, camera);
        
        // è¾‰å…‰å‚æ•°ï¼šåˆ†è¾¨ç‡, å¼ºåº¦, åŠå¾„, é˜ˆå€¼
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 1.2; // å‘å…‰å¼ºåº¦
        bloomPass.radius = 0.5;   // å‘å…‰æ‰©æ•£èŒƒå›´

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 1. åˆ›å»ºå†™å®é£æ ¼çš„æ ‘ (ç¨‹åºåŒ–ç”Ÿæˆ) ---
        function createRealisticTree() {
            const treeGroup = new THREE.Group();

            // A. æ ‘å¹² (çº¹ç†è¾ƒæ·±)
            const trunkGeo = new THREE.CylinderGeometry(0.5, 1.2, 4, 12);
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2317, roughness: 0.9 });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            treeGroup.add(trunk);

            // B. æ ‘å¶ (ä½¿ç”¨æ•°ç™¾ä¸ªå°åœ†é”¥ä½“æ¨¡æ‹ŸèŒ‚å¯†çš„é’ˆå¶)
            // è¿™ç§æ–¹æ³•æ¯”4ä¸ªå¤§åœ†é”¥ä½“è¦çœŸå®å¾—å¤š
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: 0x084a08, // æ·±é‚ƒçš„æ£®æ—ç»¿
                roughness: 0.8,
                flatShading: true // ä½å¤šè¾¹å½¢é£æ ¼ï¼Œåå…‰æ›´å¥½çœ‹
            });

            const count = 350; // æ ‘ææ•°é‡
            for (let i = 0; i < count; i++) {
                // éšç€é«˜åº¦ä¸Šå‡ï¼Œæ ‘æåŠå¾„å˜å°
                const y = Math.random() * 8 + 1; // é«˜åº¦ 1~9
                const widthRatio = (9 - y) / 9;  // åº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„
                const radius = 0.2 + Math.random() * 2.5 * widthRatio;
                const angle = Math.random() * Math.PI * 2;

                // ç®—å‡ºä½ç½®
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;

                // æ ‘æå‡ ä½•ä½“
                const size = (Math.random() * 0.5 + 0.5) * widthRatio + 0.2;
                const geo = new THREE.ConeGeometry(size, size * 2, 4);
                const mesh = new THREE.Mesh(geo, leavesMat);
                
                mesh.position.set(x, y, z);
                
                // è®©æ ‘æç¨å¾®æœå¤–å€¾æ–œ
                mesh.lookAt(0, y + 2, 0); 
                mesh.rotation.x += Math.PI / 2; // ä¿®æ­£æœå‘

                mesh.castShadow = true;
                mesh.receiveShadow = true;
                treeGroup.add(mesh);
            }

            // C. æ ‘é¡¶å¤§æ˜Ÿæ˜Ÿ (é«˜äº®å‘å…‰)
            const starGeo = new THREE.IcosahedronGeometry(0.6, 0);
            const starMat = new THREE.MeshBasicMaterial({ color: 0xfff0a0 }); // Basicæè´¨ä¸å—å…‰ç…§å½±å“ï¼Œé…åˆBloomä¼šæäº®
            const star = new THREE.Mesh(starGeo, starMat);
            star.position.y = 9.2;
            treeGroup.add(star);

            // D. è£…é¥°å½©ç¯ (Ornaments)
            // éšæœºåˆ†å¸ƒçš„å‘å…‰å°çƒ
            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulbColors = [0xff0000, 0x00ff00, 0x00ccff, 0xffaa00];
            
            for(let i=0; i<60; i++) {
                // èºæ—‹ä¸Šå‡ç®—æ³•
                const y = i * 0.14 + 1.5;
                if(y > 8.5) break;
                
                const widthRatio = (9 - y) / 9;
                const r = 2.6 * widthRatio + 0.2; // ç¨å¾®æ¯”æ ‘æå¤–ä¸€ç‚¹
                const angle = i * 0.8; // èºæ—‹è§’åº¦

                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;

                // è¿™é‡Œçš„å…³é”®æ˜¯ emissiveï¼Œè®©å®ƒè‡ªå·±å‘å…‰
                const color = bulbColors[i % bulbColors.length];
                const mat = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,     // è‡ªå‘å…‰é¢œè‰²
                    emissiveIntensity: 3.0, // å‘å…‰å¼ºåº¦ (é…åˆBloomç®€ç›´ç‚¸è£‚)
                    roughness: 0.1
                });
                
                const bulb = new THREE.Mesh(bulbGeo, mat);
                bulb.position.set(x, y, z);
                treeGroup.add(bulb);
            }

            return { group: treeGroup, star: star };
        }

        const treeObj = createRealisticTree();
        scene.add(treeObj.group);

        // --- 2. åœ°é¢ (å¸¦åå°„æ„Ÿ) ---
        const planeGeo = new THREE.CircleGeometry(15, 64);
        // Standardæè´¨è°ƒä½roughnessä¼šæœ‰è½»å¾®åå…‰æ•ˆæœï¼Œåƒé›ªåœ°
        const planeMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.8,
            metalness: 0.3
        }); 
        const plane = new THREE.Mesh(planeGeo, planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true; // æ¥æ”¶æ ‘çš„å½±å­
        scene.add(plane);

        // --- 3. æ›´æœ‰å±‚æ¬¡çš„ç¯å…‰ ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); // ç¯å¢ƒå…‰å¾ˆæš—
        scene.add(ambientLight);

        // ä¸»å…‰æº (æš–è‰²ï¼Œæ¨¡æ‹Ÿè·¯ç¯æˆ–æœˆå…‰)
        const spotLight = new THREE.SpotLight(0xffeebb, 100);
        spotLight.position.set(10, 20, 10);
        spotLight.angle = 0.5;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        spotLight.shadow.bias = -0.0001;
        scene.add(spotLight);

        // è¡¥å…‰ (å†·è‰²ï¼Œæ¨¡æ‹Ÿé›ªåœ°åå…‰)
        const pointLight = new THREE.PointLight(0x4444ff, 50, 20);
        pointLight.position.set(-5, 5, -5);
        scene.add(pointLight);

        // --- 4. ä¼˜åŒ–ç‰ˆç²’å­é›ªèŠ± ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 4000;
        const posArray = new Float32Array(snowCount * 3);
        const velArray = [];

        for(let i=0; i<snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 40;
            posArray[i+1] = Math.random() * 20;
            posArray[i+2] = (Math.random() - 0.5) * 40;
            velArray.push((Math.random() * 0.05) + 0.02);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMat = new THREE.PointsMaterial({
            size: 0.08, color: 0xffffff, transparent: true, opacity: 0.8,
            blending: THREE.AdditiveBlending // å åŠ æ··åˆï¼Œè®©é›ªèŠ±åœ¨å…‰ä¸‹æ›´äº®
        });
        const snowMesh = new THREE.Points(snowGeo, snowMat);
        scene.add(snowMesh);

        // --- éŸ³ä¹æ§åˆ¶ (ä¿æŒä¸å˜) ---
        const musicBtn = document.getElementById('music-btn');
        const bgm = document.getElementById('bgm');
        let isPlaying = false;
        musicBtn.addEventListener('click', () => {
            if (isPlaying) {
                bgm.pause(); musicBtn.textContent = "ğŸµ Play Music"; musicBtn.style.color = "white";
            } else {
                bgm.play().then(() => {
                    musicBtn.textContent = "ğŸµ Pause"; musicBtn.style.color = "#ffd700";
                }).catch(e => console.log("æ’­æ”¾å¤±è´¥", e));
            }
            isPlaying = !isPlaying;
        });

        // --- åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            // é›ªèŠ±è¿åŠ¨
            const positions = snowGeo.attributes.position.array;
            for(let i=1; i<snowCount*3; i+=3) {
                positions[i] -= velArray[(i-1)/3];
                if (positions[i] < 0) positions[i] = 20; // å¾ªç¯ä¸‹è½
            }
            snowGeo.attributes.position.needsUpdate = true;

            // æ˜Ÿæ˜Ÿå’Œæ ‘çš„å‘¼å¸ç¯æ•ˆæœ
            const time = Date.now() * 0.002;
            treeObj.star.rotation.y = time * 0.5;
            treeObj.star.scale.setScalar(1 + Math.sin(time*2) * 0.1); // æ˜Ÿæ˜Ÿé—ªçƒ

            // ä½¿ç”¨ composer æ›¿ä»£ renderer è¿›è¡Œæ¸²æŸ“ï¼Œå¯ç”¨è¾‰å…‰
            composer.render();
        }
        
        // ç§»é™¤åŠ è½½é®ç½©
        setTimeout(() => {
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => { document.getElementById('loader').style.display = 'none'; }, 1000);
        }, 1500);

        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight); // æ›´æ–°è¾‰å…‰å°ºå¯¸
        });
    </script>
</body>
</html>
