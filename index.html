<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas!To qianlin ğŸ„</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; user-select: none; }
        
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-family: 'Great Vibes', cursive; font-size: 60px;
            background: linear-gradient(to bottom, #fffebd, #ffd700); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px #ffaa00);
            pointer-events: none; z-index: 10;
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #music-btn {
            position: absolute; bottom: 30px; right: 30px; z-index: 20;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; border-radius: 30px; cursor: pointer;
            font-family: sans-serif; font-size: 14px; backdrop-filter: blur(5px); transition: 0.3s;
        }
        #music-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #000; color: #ffd700; display: flex;
            justify-content: center; align-items: center; font-family: sans-serif;
            z-index: 999; transition: opacity 1s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">æ­£åœ¨ç²¾å¿ƒåŒ…è£…ç¤¼ç‰©...</div>
    <div id="info">Merry Christmas & Happy New Year</div>
    <button id="music-btn">ğŸµ Play Music</button>
    <audio id="bgm" loop><source src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/win.ogg" type="audio/ogg"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- åæœŸè¾‰å…‰ ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆåŒ…è£…çº¸çº¹ç† ---
        function createWrappingTexture(color1, color2, type = 'stripes') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // åº•è‰²
            ctx.fillStyle = color1;
            ctx.fillRect(0,0,128,128);
            ctx.fillStyle = color2;

            if (type === 'stripes') {
                for(let i=0; i<6; i++) {
                    ctx.beginPath();
                    ctx.moveTo(i*25, 0); ctx.lineTo(i*25+15, 0);
                    ctx.lineTo(i*25-10, 128); ctx.lineTo(i*25-25, 128);
                    ctx.fill();
                }
            } else if (type === 'dots') {
                for(let i=0; i<10; i++) {
                    for(let j=0; j<10; j++) {
                        ctx.beginPath();
                        ctx.arc(i*15, j*15, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                }
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- 1. åœ£è¯æ ‘ ---
        function createRealisticTree() {
            const treeGroup = new THREE.Group();
            
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2317, roughness: 0.9 });
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1.2, 4, 12), trunkMat);
            trunk.position.y = 2; trunk.castShadow = true; trunk.receiveShadow = true;
            treeGroup.add(trunk);

            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x084a08, roughness: 0.8, flatShading: true });
            for (let i = 0; i < 350; i++) {
                const y = Math.random() * 8 + 1;
                const widthRatio = (9 - y) / 9;
                const radius = 0.2 + Math.random() * 2.5 * widthRatio;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const size = (Math.random() * 0.5 + 0.5) * widthRatio + 0.2;
                const mesh = new THREE.Mesh(new THREE.ConeGeometry(size, size * 2, 4), leavesMat);
                mesh.position.set(x, y, z);
                mesh.lookAt(0, y + 2, 0); mesh.rotation.x += Math.PI / 2;
                mesh.castShadow = true; mesh.receiveShadow = true;
                treeGroup.add(mesh);
            }

            const star = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshBasicMaterial({ color: 0xfff0a0 }));
            star.position.y = 9.2;
            treeGroup.add(star);

            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulbColors = [0xff0000, 0x00ff00, 0x00ccff, 0xffaa00];
            for(let i=0; i<60; i++) {
                const y = i * 0.14 + 1.5; if(y > 8.5) break;
                const r = 2.6 * ((9 - y) / 9) + 0.2;
                const angle = i * 0.8;
                const color = bulbColors[i % bulbColors.length];
                const bulb = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({
                    color: color, emissive: color, emissiveIntensity: 3.0, roughness: 0.1
                }));
                bulb.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                treeGroup.add(bulb);
            }
            return { group: treeGroup, star: star };
        }
        const treeObj = createRealisticTree();
        scene.add(treeObj.group);

        // --- 2. ç²¾ç¾ç¤¼ç‰©ç›’ (å‡çº§ç‰ˆ) ---
        function createLuxuryGifts() {
            const giftsGroup = new THREE.Group();
            
            // åŒ…è£…é…è‰²æ–¹æ¡ˆ
            const palettes = [
                { paper: '#D32F2F', pattern: '#B71C1C', ribbon: 0xFFD700, type: 'stripes' }, // çº¢é‡‘
                { paper: '#1976D2', pattern: '#0D47A1', ribbon: 0xC0C0C0, type: 'dots' },    // è“é“¶
                { paper: '#388E3C', pattern: '#1B5E20', ribbon: 0xD32F2F, type: 'stripes' }, // ç»¿çº¢
                { paper: '#FBC02D', pattern: '#F9A825', ribbon: 0xFFFFFF, type: 'dots' },    // é‡‘ç™½
                { paper: '#7B1FA2', pattern: '#4A148C', ribbon: 0xFFD700, type: 'stripes' }  // ç´«é‡‘
            ];

            for(let i=0; i<18; i++) {
                // éšæœºå‚æ•°
                const palette = palettes[Math.floor(Math.random() * palettes.length)];
                const w = Math.random() * 0.6 + 0.5; // å®½
                const h = Math.random() * 0.6 + 0.4; // é«˜
                const d = Math.random() * 0.6 + 0.5; // æ·±
                const radius = Math.random() * 2.5 + 2.5; 
                const angle = Math.random() * Math.PI * 2;
                
                const boxGroup = new THREE.Group();
                boxGroup.position.set(Math.cos(angle)*radius, h/2 - 2, Math.sin(angle)*radius);
                boxGroup.rotation.y = Math.random() * Math.PI;

                // 2.1 ç›’å­æœ¬ä½“ (å¸¦çº¹ç†)
                const texture = createWrappingTexture(palette.paper, palette.pattern, palette.type);
                const boxGeo = new THREE.BoxGeometry(w, h, d);
                const boxMat = new THREE.MeshStandardMaterial({ 
                    map: texture, roughness: 0.4, metalness: 0.1 
                });
                const box = new THREE.Mesh(boxGeo, boxMat);
                box.castShadow = true; box.receiveShadow = true;
                boxGroup.add(box);

                // 2.2 ä¸å¸¦ (ç¼é¢æè´¨)
                const ribbonMat = new THREE.MeshStandardMaterial({ 
                    color: palette.ribbon, roughness: 0.2, metalness: 0.6 
                });
                // çºµå‘ä¸å¸¦
                const r1 = new THREE.Mesh(new THREE.BoxGeometry(w*1.02, h*1.01, d*0.15), ribbonMat);
                // æ¨ªå‘ä¸å¸¦
                const r2 = new THREE.Mesh(new THREE.BoxGeometry(w*0.15, h*1.01, d*1.02), ribbonMat);
                boxGroup.add(r1);
                boxGroup.add(r2);

                // 2.3 è´è¶ç»“ (TorusKnot æ¨¡æ‹Ÿ)
                const knotGeo = new THREE.TorusKnotGeometry(0.15, 0.05, 64, 8, 2, 3);
                const knot = new THREE.Mesh(knotGeo, ribbonMat);
                knot.position.y = h/2 + 0.15;
                knot.scale.set(1, 0.5, 1); // å‹æ‰ä¸€ç‚¹
                boxGroup.add(knot);

                giftsGroup.add(boxGroup);
            }
            scene.add(giftsGroup);
        }
        createLuxuryGifts();

        // --- 3. åœ£è¯è€äººä¸é©¯é¹¿ ---
        function createSantaSleigh() {
            const sleighGroup = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.6, 2);
            const redMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
            const sleighBody = new THREE.Mesh(bodyGeo, redMat);
            sleighBody.castShadow = true;
            sleighGroup.add(sleighBody);

            const body = new THREE.Mesh(new THREE.SphereGeometry(0.4), redMat);
            body.position.set(0, 0.6, -0.2);
            sleighGroup.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
            head.position.set(0, 1.1, -0.2);
            sleighGroup.add(head);

            const deerGeo = new THREE.BoxGeometry(0.4, 0.4, 0.8);
            const deerMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
            for(let z=0; z<2; z++) {
                for(let x=-1; x<=1; x+=2) {
                    const deer = new THREE.Mesh(deerGeo, deerMat);
                    deer.position.set(x * 0.5, 0, 2 + z * 1.2); 
                    sleighGroup.add(deer);
                    if(z===1) {
                         const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({color:0xff0000}));
                         nose.position.set(0, 0, 0.4); deer.add(nose);
                    }
                }
            }
            const sleighLight = new THREE.PointLight(0xffaa00, 20, 10);
            sleighLight.position.set(0, 1, 0);
            sleighGroup.add(sleighLight);
            return sleighGroup;
        }
        const santaObj = createSantaSleigh();
        scene.add(santaObj);

        // --- ç¯å¢ƒ ---
        const plane = new THREE.Mesh(
            new THREE.CircleGeometry(20, 64),
            new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.3 })
        );
        plane.rotation.x = -Math.PI / 2; plane.position.y = -2; plane.receiveShadow = true;
        scene.add(plane);

        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        const spotLight = new THREE.SpotLight(0xffeebb, 100);
        spotLight.position.set(10, 20, 10); spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add(new THREE.PointLight(0x4444ff, 50, 20).translateX(-5).translateY(5).translateZ(-5));

        // --- é›ªèŠ± ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 4000;
        const posArray = new Float32Array(snowCount * 3);
        const velArray = [];
        for(let i=0; i<snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 50;
            posArray[i+1] = Math.random() * 20;
            posArray[i+2] = (Math.random() - 0.5) * 50;
            velArray.push((Math.random() * 0.05) + 0.02);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMesh = new THREE.Points(snowGeo, new THREE.PointsMaterial({
            size: 0.08, color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
        }));
        scene.add(snowMesh);

        // --- éŸ³ä¹ ---
        const musicBtn = document.getElementById('music-btn');
        const bgm = document.getElementById('bgm');
        let isPlaying = false;
        musicBtn.addEventListener('click', () => {
            if (isPlaying) { bgm.pause(); musicBtn.textContent = "ğŸµ Play Music"; musicBtn.style.color = "white"; } 
            else { bgm.play().then(() => { musicBtn.textContent = "ğŸµ Pause"; musicBtn.style.color = "#ffd700"; }); }
            isPlaying = !isPlaying;
        });

        // --- åŠ¨ç”» ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.002;
            const elapsedTime = clock.getElapsedTime();

            const positions = snowGeo.attributes.position.array;
            for(let i=1; i<snowCount*3; i+=3) {
                positions[i] -= velArray[(i-1)/3];
                if (positions[i] < -2) positions[i] = 20;
            }
            snowGeo.attributes.position.needsUpdate = true;

            treeObj.star.rotation.y = time * 0.5;
            treeObj.star.scale.setScalar(1 + Math.sin(time*2) * 0.1);

            const flyRadius = 10;
            const flyHeight = 8;
            const flySpeed = 0.3;
            santaObj.position.x = Math.sin(elapsedTime * flySpeed) * flyRadius;
            santaObj.position.z = Math.cos(elapsedTime * flySpeed) * flyRadius;
            santaObj.position.y = flyHeight + Math.sin(elapsedTime * 1) * 1.5;
            santaObj.lookAt(
                Math.sin(elapsedTime * flySpeed + 0.1) * flyRadius, 
                flyHeight + Math.sin((elapsedTime + 0.1) * 1) * 1.5, 
                Math.cos(elapsedTime * flySpeed + 0.1) * flyRadius
            );

            composer.render();
        }

        setTimeout(() => { document.getElementById('loader').style.opacity = '0'; setTimeout(() => document.getElementById('loader').style.display = 'none', 1000); }, 1500);
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
