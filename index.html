<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas! ğŸ„</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; user-select: none; }
        
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-family: 'Great Vibes', cursive; font-size: 60px;
            background: linear-gradient(to bottom, #fffebd, #ffd700); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px #ffaa00);
            pointer-events: none; z-index: 10;
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #music-btn {
            position: absolute; bottom: 30px; right: 30px; z-index: 20;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; border-radius: 30px; cursor: pointer;
            font-family: sans-serif; font-size: 14px; backdrop-filter: blur(5px); transition: 0.3s;
        }
        #music-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #000; color: #ffd700; display: flex;
            justify-content: center; align-items: center; font-family: sans-serif;
            z-index: 999; transition: opacity 1s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">åœ£è¯è€äººæ­£åœ¨ç»™é©¯é¹¿å–‚è‰...</div>
    <div id="info">Merry Christmas & Happy New Year</div>
    <button id="music-btn">ğŸµ Play Music</button>
    <audio id="bgm" loop>
    <source src="./music.mp3" type="audio/mpeg"> 
</audio>
    
    <script type="module">
        // --- â­ é­”æ³•ä»£ç å¼€å§‹ï¼šè‡ªåŠ¨è·å–åå­— â­ ---
        // è·å–ç½‘å€é“¾æ¥é‡Œ ?to= åé¢çš„å†…å®¹
        const params = new URLSearchParams(window.location.search);
        let name = params.get('to'); 
        const infoDiv = document.getElementById('info');
        
        if (name) {
            // å¦‚æœé“¾æ¥é‡Œæœ‰åå­—ï¼Œå°±æ›¿æ¢æ‰é»˜è®¤æ–‡å­—
            // è‡ªåŠ¨è§£ç ï¼ˆé˜²æ­¢ä¸­æ–‡ä¹±ç ï¼‰å¹¶æ˜¾ç¤º
            name = decodeURIComponent(name);
            
            // è¿™é‡Œä½ å¯ä»¥è‡ªç”±ä¿®æ”¹æ˜¾ç¤ºæ ¼å¼ï¼Œ<br> ä»£è¡¨æ¢è¡Œ
            // æ¯”å¦‚æ”¹æˆï¼š `ç¥ ${name} <br> åœ£è¯å¿«ä¹!`
            infoDiv.innerHTML = `Merry Christmas<br>${name}`;
            
            // é¡ºä¾¿æŠŠæµè§ˆå™¨æ ‡ç­¾é¡µæ ‡é¢˜ä¹Ÿæ”¹äº†
            document.title = `ç¥ ${name} åœ£è¯å¿«ä¹!`;
            
            // å¦‚æœåå­—å¤ªé•¿ï¼ˆæ¯”å¦‚ä¸­æ–‡åï¼‰ï¼Œç¨å¾®æŠŠå­—å·è°ƒå°ä¸€ç‚¹ç‚¹é˜²æ­¢æ¢è¡Œå¤ªéš¾çœ‹
            if (name.length > 3) {
                infoDiv.style.fontSize = "50px";
                infoDiv.style.lineHeight = "1.2";
            }
        }
        // --- é­”æ³•ä»£ç ç»“æŸ ---
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 14);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.05;

        // --- åæœŸè¾‰å…‰ ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0; bloomPass.strength = 1.0; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- è¾…åŠ©å‡½æ•°ï¼šç”ŸæˆåŒ…è£…çº¸çº¹ç† ---
        function createWrappingTexture(color1, color2, type = 'stripes') {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color1; ctx.fillRect(0,0,128,128); ctx.fillStyle = color2;
            if (type === 'stripes') {
                for(let i=0; i<6; i++) {
                    ctx.beginPath(); ctx.moveTo(i*25, 0); ctx.lineTo(i*25+15, 0);
                    ctx.lineTo(i*25-10, 128); ctx.lineTo(i*25-25, 128); ctx.fill();
                }
            } else if (type === 'dots') {
                for(let i=0; i<10; i++) { for(let j=0; j<10; j++) { ctx.beginPath(); ctx.arc(i*15, j*15, 3, 0, Math.PI*2); ctx.fill(); }}
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }

        // --- 1. åœ£è¯æ ‘ ---
        function createRealisticTree() {
            const treeGroup = new THREE.Group();
            
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2317, roughness: 0.9 });
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1.2, 4, 12), trunkMat);
            trunk.position.y = 2; trunk.castShadow = true; trunk.receiveShadow = true;
            treeGroup.add(trunk);

            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x084a08, roughness: 0.8, flatShading: true });
            for (let i = 0; i < 350; i++) {
                const y = Math.random() * 8 + 1;
                const widthRatio = (9 - y) / 9;
                const radius = 0.2 + Math.random() * 2.5 * widthRatio;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const size = (Math.random() * 0.5 + 0.5) * widthRatio + 0.2;
                const mesh = new THREE.Mesh(new THREE.ConeGeometry(size, size * 2, 4), leavesMat);
                mesh.position.set(x, y, z);
                mesh.lookAt(0, y + 2, 0); mesh.rotation.x += Math.PI / 2;
                mesh.castShadow = true; mesh.receiveShadow = true;
                treeGroup.add(mesh);
            }

            const star = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshBasicMaterial({ color: 0xfff0a0 }));
            star.position.y = 9.2;
            treeGroup.add(star);

            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulbColors = [0xff0000, 0x00ff00, 0x00ccff, 0xffaa00];
            for(let i=0; i<60; i++) {
                const y = i * 0.14 + 1.5; if(y > 8.5) break;
                const r = 2.6 * ((9 - y) / 9) + 0.2;
                const angle = i * 0.8;
                const color = bulbColors[i % bulbColors.length];
                const bulb = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({
                    color: color, emissive: color, emissiveIntensity: 3.0, roughness: 0.1
                }));
                bulb.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                treeGroup.add(bulb);
            }
            return { group: treeGroup, star: star };
        }
        const treeObj = createRealisticTree();
        scene.add(treeObj.group);

        // --- 2. ç¤¼ç‰©ç›’ ---
        function createLuxuryGifts() {
            const giftsGroup = new THREE.Group();
            const palettes = [
                { paper: '#D32F2F', pattern: '#B71C1C', ribbon: 0xFFD700, type: 'stripes' },
                { paper: '#1976D2', pattern: '#0D47A1', ribbon: 0xC0C0C0, type: 'dots' },
                { paper: '#388E3C', pattern: '#1B5E20', ribbon: 0xD32F2F, type: 'stripes' },
                { paper: '#FBC02D', pattern: '#F9A825', ribbon: 0xFFFFFF, type: 'dots' },
                { paper: '#7B1FA2', pattern: '#4A148C', ribbon: 0xFFD700, type: 'stripes' }
            ];
            for(let i=0; i<18; i++) {
                const palette = palettes[Math.floor(Math.random() * palettes.length)];
                const w = Math.random() * 0.6 + 0.5;
                const h = Math.random() * 0.6 + 0.4;
                const d = Math.random() * 0.6 + 0.5;
                const radius = Math.random() * 2.5 + 2.5; 
                const angle = Math.random() * Math.PI * 2;
                
                const boxGroup = new THREE.Group();
                boxGroup.position.set(Math.cos(angle)*radius, h/2 - 2, Math.sin(angle)*radius);
                boxGroup.rotation.y = Math.random() * Math.PI;

                const texture = createWrappingTexture(palette.paper, palette.pattern, palette.type);
                const boxMat = new THREE.MeshStandardMaterial({ map: texture, roughness: 0.4 });
                const box = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), boxMat);
                box.castShadow = true; box.receiveShadow = true;
                boxGroup.add(box);

                const ribbonMat = new THREE.MeshStandardMaterial({ color: palette.ribbon, roughness: 0.2, metalness: 0.6 });
                boxGroup.add(new THREE.Mesh(new THREE.BoxGeometry(w*1.02, h*1.01, d*0.15), ribbonMat));
                boxGroup.add(new THREE.Mesh(new THREE.BoxGeometry(w*0.15, h*1.01, d*1.02), ribbonMat));
                
                const knot = new THREE.Mesh(new THREE.TorusKnotGeometry(0.15, 0.05, 64, 8), ribbonMat);
                knot.position.y = h/2 + 0.15; knot.scale.set(1, 0.5, 1);
                boxGroup.add(knot);

                giftsGroup.add(boxGroup);
            }
            scene.add(giftsGroup);
        }
        createLuxuryGifts();

        // --- 3. ç²¾è‡´ç‰ˆåœ£è¯è€äººä¸é©¯é¹¿ ---
        function createSantaSleigh() {
            const sleighGroup = new THREE.Group();
            
            // A. é›ªæ©‡ (Sleigh) - é‡‘è‰²æ»‘è½¨
            const runnerGeo = new THREE.TorusGeometry(1, 0.05, 8, 30, Math.PI);
            const goldMat = new THREE.MeshStandardMaterial({ color: 0xffaa00, metalness: 0.8, roughness: 0.2 });
            const redPaintMat = new THREE.MeshStandardMaterial({ color: 0xaa0000, roughness: 0.3 });

            // å·¦æ»‘è½¨
            const runnerL = new THREE.Mesh(runnerGeo, goldMat);
            runnerL.position.set(-0.6, 0.3, 0.5); runnerL.rotation.y = Math.PI / 2;
            sleighGroup.add(runnerL);
            // å³æ»‘è½¨
            const runnerR = new THREE.Mesh(runnerGeo, goldMat);
            runnerR.position.set(0.6, 0.3, 0.5); runnerR.rotation.y = Math.PI / 2;
            sleighGroup.add(runnerR);

            // è½¦èº« (Curved Body simulation)
            const bodyBottom = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.8), redPaintMat);
            bodyBottom.position.set(0, 0.6, 0.5);
            sleighGroup.add(bodyBottom);
            
            // è½¦å¢ä¾§æ¿
            const sideGeo = new THREE.BoxGeometry(0.1, 0.6, 1.6);
            const sideL = new THREE.Mesh(sideGeo, redPaintMat); sideL.position.set(-0.55, 0.9, 0.5);
            const sideR = new THREE.Mesh(sideGeo, redPaintMat); sideR.position.set(0.55, 0.9, 0.5);
            sleighGroup.add(sideL); sleighGroup.add(sideR);

            // B. åœ£è¯è€äºº (Santa)
            const santaGroup = new THREE.Group();
            santaGroup.position.set(0, 0.8, 0.2);
            
            // èº«ä½“
            const santaBody = new THREE.Mesh(new THREE.SphereGeometry(0.4, 16, 16), redPaintMat);
            santaGroup.add(santaBody);
            // è„‘è¢‹
            const skinMat = new THREE.MeshStandardMaterial({ color: 0xffccaa });
            const santaHead = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), skinMat);
            santaHead.position.y = 0.5;
            santaGroup.add(santaHead);
            // çœ¼ç›
            const eyeGeo = new THREE.SphereGeometry(0.03);
            const blackMat = new THREE.MeshBasicMaterial({color: 0x000000});
            const eyeL = new THREE.Mesh(eyeGeo, blackMat); eyeL.position.set(-0.1, 0.55, 0.22);
            const eyeR = new THREE.Mesh(eyeGeo, blackMat); eyeR.position.set(0.1, 0.55, 0.22);
            santaGroup.add(eyeL); santaGroup.add(eyeR);
            // èƒ¡å­
            const beardGeo = new THREE.SphereGeometry(0.15, 16, 16);
            const whiteMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 1 });
            const beard = new THREE.Mesh(beardGeo, whiteMat);
            beard.position.set(0, 0.45, 0.22);
            santaGroup.add(beard);
            // å¸½å­
            const hatGeo = new THREE.ConeGeometry(0.26, 0.5, 16);
            const hat = new THREE.Mesh(hatGeo, redPaintMat);
            hat.position.set(0, 0.8, 0); hat.rotation.x = -0.2;
            santaGroup.add(hat);
            const pompom = new THREE.Mesh(new THREE.SphereGeometry(0.08), whiteMat);
            pompom.position.set(0, 1.05, -0.1);
            santaGroup.add(pompom);

            sleighGroup.add(santaGroup);

            // C. é©¯é¹¿ (Reindeer)
            const deerColor = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
            const antlerColor = new THREE.MeshStandardMaterial({ color: 0x3e2714 });

            function createDeer() {
                const deer = new THREE.Group();
                // èº«ä½“
                const body = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8), deerColor);
                body.rotation.x = Math.PI / 2; body.position.y = 0.5;
                deer.add(body);
                // è„–å­
                const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.2, 0.4), deerColor);
                neck.position.set(0, 0.8, 0.3); neck.rotation.x = -0.5;
                deer.add(neck);
                // å¤´
                const head = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.4), deerColor);
                head.position.set(0, 1.0, 0.5);
                deer.add(head);
                // è…¿
                const legGeo = new THREE.CylinderGeometry(0.06, 0.05, 0.5);
                const legFL = new THREE.Mesh(legGeo, deerColor); legFL.position.set(-0.15, 0.25, 0.3);
                const legFR = new THREE.Mesh(legGeo, deerColor); legFR.position.set(0.15, 0.25, 0.3);
                const legBL = new THREE.Mesh(legGeo, deerColor); legBL.position.set(-0.15, 0.25, -0.3);
                const legBR = new THREE.Mesh(legGeo, deerColor); legBR.position.set(0.15, 0.25, -0.3);
                deer.add(legFL); deer.add(legFR); deer.add(legBL); deer.add(legBR);
                // é¹¿è§’
                const antlerGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4);
                const antL = new THREE.Mesh(antlerGeo, antlerColor);
                antL.position.set(-0.15, 1.3, 0.4); antL.rotation.z = 0.5;
                const antR = new THREE.Mesh(antlerGeo, antlerColor);
                antR.position.set(0.15, 1.3, 0.4); antR.rotation.z = -0.5;
                deer.add(antL); deer.add(antR);

                return deer;
            }

            // åˆ›å»ºä¸¤æ’é©¯é¹¿ (4åª)
            for(let z=0; z<2; z++) {
                for(let x=-1; x<=1; x+=2) {
                    const deer = createDeer();
                    deer.position.set(x * 0.5, 0, 2.5 + z * 1.5);
                    sleighGroup.add(deer);
                    
                    // é²é“å¤«çº¢é¼»å­ (æœ€å‰é¢ä¸€åª)
                    if(z===1 && x=== -1) { 
                         const nose = new THREE.Mesh(new THREE.SphereGeometry(0.06), new THREE.MeshBasicMaterial({color:0xff0000}));
                         nose.position.set(0, 1.0, 0.72);
                         // æ‰¾åˆ°é¹¿å¤´å¹¶æ·»åŠ é¼»å­ (é¹¿å¤´æ˜¯ç¬¬2ä¸ªæ·»åŠ çš„å­å…ƒç´ ? ä¸ä¸€å®šï¼ŒæŒ‰å±‚çº§æ‰¾)
                         deer.children[2].add(nose);
                    }
                }
            }

            // é›ªæ©‡ç¯
            const sleighLight = new THREE.PointLight(0xffaa00, 20, 10);
            sleighLight.position.set(0, 1, 1);
            sleighGroup.add(sleighLight);

            return sleighGroup;
        }

        const santaObj = createSantaSleigh();
        scene.add(santaObj);

        // --- 4. é­”æ³•æ‹–å°¾ (Magic Trail) ---
        const trailCount = 50;
        const trailGeo = new THREE.BufferGeometry();
        const trailPos = new Float32Array(trailCount * 3);
        trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
        const trailMat = new THREE.PointsMaterial({ color: 0xffd700, size: 0.3, transparent: true, opacity: 0.6 });
        const trail = new THREE.Points(trailGeo, trailMat);
        scene.add(trail);
        
        // --- ç¯å¢ƒ ---
        const plane = new THREE.Mesh(new THREE.CircleGeometry(20, 64), new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.3 }));
        plane.rotation.x = -Math.PI / 2; plane.position.y = -2; plane.receiveShadow = true;
        scene.add(plane);

        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        const spotLight = new THREE.SpotLight(0xffeebb, 100);
        spotLight.position.set(10, 20, 10); spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add(new THREE.PointLight(0x4444ff, 50, 20).translateX(-5).translateY(5).translateZ(-5));

        // --- é›ªèŠ± ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 4000;
        const posArray = new Float32Array(snowCount * 3);
        const velArray = [];
        for(let i=0; i<snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 50;
            posArray[i+1] = Math.random() * 20;
            posArray[i+2] = (Math.random() - 0.5) * 50;
            velArray.push((Math.random() * 0.05) + 0.02);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMesh = new THREE.Points(snowGeo, new THREE.PointsMaterial({ size: 0.08, color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending }));
        scene.add(snowMesh);

        // --- éŸ³ä¹ ---
        const musicBtn = document.getElementById('music-btn');
        const bgm = document.getElementById('bgm');
        let isPlaying = false;
        musicBtn.addEventListener('click', () => {
            if (isPlaying) { bgm.pause(); musicBtn.textContent = "ğŸµ Play Music"; musicBtn.style.color = "white"; } 
            else { bgm.play().then(() => { musicBtn.textContent = "ğŸµ Pause"; musicBtn.style.color = "#ffd700"; }); }
            isPlaying = !isPlaying;
        });

        // --- åŠ¨ç”» ---
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.002;
            const elapsedTime = clock.getElapsedTime();

            // é›ªèŠ±
            const positions = snowGeo.attributes.position.array;
            for(let i=1; i<snowCount*3; i+=3) {
                positions[i] -= velArray[(i-1)/3];
                if (positions[i] < -2) positions[i] = 20;
            }
            snowGeo.attributes.position.needsUpdate = true;

            // åœ£è¯æ ‘æ˜Ÿæ˜Ÿ
            treeObj.star.rotation.y = time * 0.5;
            treeObj.star.scale.setScalar(1 + Math.sin(time*2) * 0.1);

            // åœ£è¯è€äººé£è¡Œ
            const flyRadius = 10;
            const flyHeight = 8;
            const flySpeed = 0.3;
            // è®¡ç®—å½“å‰ä½ç½®
            const sx = Math.sin(elapsedTime * flySpeed) * flyRadius;
            const sz = Math.cos(elapsedTime * flySpeed) * flyRadius;
            const sy = flyHeight + Math.sin(elapsedTime * 1) * 1.5;
            
            santaObj.position.set(sx, sy, sz);
            // è®¡ç®—æœå‘ç›®æ ‡ç‚¹ (ç¨å¾®è¶…å‰ä¸€ç‚¹)
            santaObj.lookAt(
                Math.sin(elapsedTime * flySpeed + 0.1) * flyRadius, 
                flyHeight + Math.sin((elapsedTime + 0.1) * 1) * 1.5, 
                Math.cos(elapsedTime * flySpeed + 0.1) * flyRadius
            );

            // é­”æ³•æ‹–å°¾é€»è¾‘
            // å°†æ‰€æœ‰ç‚¹å‘åç§»ä¸€ä½
            const trailPositions = trailGeo.attributes.position.array;
            for (let i = (trailCount - 1) * 3; i > 0; i--) {
                trailPositions[i] = trailPositions[i - 3];
            }
            // è®¾ç½®ç¬¬ä¸€ä¸ªç‚¹ä¸ºå½“å‰é›ªæ©‡ä½ç½® (ç¨å¾®åœ¨è½¦å°¾)
            trailPositions[0] = sx;
            trailPositions[1] = sy + 0.5;
            trailPositions[2] = sz;
            trailGeo.attributes.position.needsUpdate = true;

            composer.render();
        }

        setTimeout(() => { document.getElementById('loader').style.opacity = '0'; setTimeout(() => document.getElementById('loader').style.display = 'none', 1000); }, 1500);
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
