<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Merry Christmas! ğŸ„</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&display=swap" rel="stylesheet">
    
    <style>
        body { margin: 0; overflow: hidden; background-color: #020205; user-select: none; }
        
        #info {
            position: absolute; top: 20px; width: 100%; text-align: center;
            font-family: 'Great Vibes', cursive; font-size: 60px;
            background: linear-gradient(to bottom, #fffebd, #ffd700); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 10px #ffaa00);
            pointer-events: none; z-index: 10;
            animation: floatText 3s ease-in-out infinite;
        }

        @keyframes floatText {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

        #music-btn {
            position: absolute; bottom: 30px; right: 30px; z-index: 20;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; border-radius: 30px; cursor: pointer;
            font-family: sans-serif; font-size: 14px; backdrop-filter: blur(5px); transition: 0.3s;
        }
        #music-btn:hover { background: rgba(255, 255, 255, 0.3); transform: scale(1.05); }
        
        #loader {
            position: absolute; top:0; left:0; width:100%; height:100%;
            background: #000; color: #ffd700; display: flex;
            justify-content: center; align-items: center; font-family: sans-serif;
            z-index: 999; transition: opacity 1s;
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loader">æ­£åœ¨æ‰“åŒ…åœ£è¯ç¤¼ç‰©...</div>
    <div id="info">Merry Christmas & Happy New Year</div>
    <button id="music-btn">ğŸµ Play Music</button>
    <audio id="bgm" loop><source src="https://commondatastorage.googleapis.com/codeskulptor-demos/riceracer_assets/music/win.ogg" type="audio/ogg"></audio>
    
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.02); 

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ReinhardToneMapping;
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        // --- åæœŸè¾‰å…‰ ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0; bloomPass.strength = 1.2; bloomPass.radius = 0.5;
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 1. åœ£è¯æ ‘ (ä¿æŒä¼˜åŒ–åçš„åä¸½ç‰ˆ) ---
        function createRealisticTree() {
            const treeGroup = new THREE.Group();
            
            // æ ‘å¹²
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x3d2317, roughness: 0.9 });
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 1.2, 4, 12), trunkMat);
            trunk.position.y = 2; trunk.castShadow = true; trunk.receiveShadow = true;
            treeGroup.add(trunk);

            // æ ‘æ
            const leavesMat = new THREE.MeshStandardMaterial({ color: 0x084a08, roughness: 0.8, flatShading: true });
            for (let i = 0; i < 350; i++) {
                const y = Math.random() * 8 + 1;
                const widthRatio = (9 - y) / 9;
                const radius = 0.2 + Math.random() * 2.5 * widthRatio;
                const angle = Math.random() * Math.PI * 2;
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                const size = (Math.random() * 0.5 + 0.5) * widthRatio + 0.2;
                const mesh = new THREE.Mesh(new THREE.ConeGeometry(size, size * 2, 4), leavesMat);
                mesh.position.set(x, y, z);
                mesh.lookAt(0, y + 2, 0); mesh.rotation.x += Math.PI / 2;
                mesh.castShadow = true; mesh.receiveShadow = true;
                treeGroup.add(mesh);
            }

            // æ˜Ÿæ˜Ÿ
            const star = new THREE.Mesh(new THREE.IcosahedronGeometry(0.6, 0), new THREE.MeshBasicMaterial({ color: 0xfff0a0 }));
            star.position.y = 9.2;
            treeGroup.add(star);

            // è£…é¥°ç¯
            const bulbGeo = new THREE.SphereGeometry(0.12, 8, 8);
            const bulbColors = [0xff0000, 0x00ff00, 0x00ccff, 0xffaa00];
            for(let i=0; i<60; i++) {
                const y = i * 0.14 + 1.5; if(y > 8.5) break;
                const r = 2.6 * ((9 - y) / 9) + 0.2;
                const angle = i * 0.8;
                const color = bulbColors[i % bulbColors.length];
                const bulb = new THREE.Mesh(bulbGeo, new THREE.MeshStandardMaterial({
                    color: color, emissive: color, emissiveIntensity: 3.0, roughness: 0.1
                }));
                bulb.position.set(Math.cos(angle)*r, y, Math.sin(angle)*r);
                treeGroup.add(bulb);
            }
            return { group: treeGroup, star: star };
        }
        const treeObj = createRealisticTree();
        scene.add(treeObj.group);

        // --- 2. ç¤¼ç‰©ç›’ (NEW!) ---
        function createGifts() {
            const giftsGroup = new THREE.Group();
            const colors = [0xd11f1f, 0x1f7ad1, 0xd1b91f, 0xffffff, 0x1fd169];
            
            for(let i=0; i<15; i++) {
                // éšæœºå¤§å°å’Œä½ç½®
                const size = Math.random() * 0.8 + 0.4;
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 2 + 2.5; // åˆ†å¸ƒåœ¨æ ‘å‘¨å›´ 2.5~4.5 èŒƒå›´å†…
                const x = Math.cos(angle) * radius;
                const z = Math.sin(angle) * radius;
                
                const boxGeo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshStandardMaterial({ 
                    color: colors[Math.floor(Math.random()*colors.length)],
                    roughness: 0.3, metalness: 0.1
                });
                const box = new THREE.Mesh(boxGeo, mat);
                box.position.set(x, size/2 - 2, z); // æ”¾åœ¨åœ°ä¸Š
                box.rotation.y = Math.random();
                box.castShadow = true; box.receiveShadow = true;

                // ä¸å¸¦ (åå­—äº¤å‰)
                const ribbonMat = new THREE.MeshStandardMaterial({ color: 0xffd700, roughness: 0.2, metalness: 0.8 });
                const ribbon1 = new THREE.Mesh(new THREE.BoxGeometry(size*1.02, size*0.1, size*1.02), ribbonMat);
                const ribbon2 = new THREE.Mesh(new THREE.BoxGeometry(size*0.1, size*1.02, size*1.02), ribbonMat);
                box.add(ribbon1);
                box.add(ribbon2);

                giftsGroup.add(box);
            }
            scene.add(giftsGroup);
        }
        createGifts();

        // --- 3. åœ£è¯è€äººä¸é©¯é¹¿ (NEW!) ---
        function createSantaSleigh() {
            const sleighGroup = new THREE.Group();
            
            // é›ªæ©‡æœ¬ä½“ (çº¢è‰²æ–¹å—)
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.6, 2);
            const redMat = new THREE.MeshStandardMaterial({ color: 0xaa0000 });
            const sleighBody = new THREE.Mesh(bodyGeo, redMat);
            sleighBody.castShadow = true;
            sleighGroup.add(sleighBody);

            // åœ£è¯è€äºº (ç®€å•çš„çƒä½“å †å )
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.4), redMat);
            body.position.set(0, 0.6, -0.2);
            sleighGroup.add(body);
            
            const head = new THREE.Mesh(new THREE.SphereGeometry(0.25), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
            head.position.set(0, 1.1, -0.2);
            sleighGroup.add(head);

            // é©¯é¹¿ (æç®€é£æ ¼çš„æ£•è‰²æ–¹å—)
            const deerGeo = new THREE.BoxGeometry(0.4, 0.4, 0.8);
            const deerMat = new THREE.MeshStandardMaterial({ color: 0x5c3a21 });
            
            // ä¸¤æ’é©¯é¹¿
            for(let z=0; z<2; z++) {
                for(let x=-1; x<=1; x+=2) {
                    const deer = new THREE.Mesh(deerGeo, deerMat);
                    // æ”¾åœ¨é›ªæ©‡å‰é¢
                    deer.position.set(x * 0.5, 0, 2 + z * 1.2); 
                    sleighGroup.add(deer);
                    
                    // ç®€å•çš„çº¢é¼»å­ (é²é“å¤«)
                    if(z===1) {
                         const nose = new THREE.Mesh(new THREE.SphereGeometry(0.08), new THREE.MeshBasicMaterial({color:0xff0000}));
                         nose.position.set(0, 0, 0.4);
                         deer.add(nose);
                    }
                }
            }

            // é›ªæ©‡ä¸Šçš„ç¯
            const sleighLight = new THREE.PointLight(0xffaa00, 20, 10);
            sleighLight.position.set(0, 1, 0);
            sleighGroup.add(sleighLight);

            return sleighGroup;
        }

        const santaObj = createSantaSleigh();
        scene.add(santaObj);


        // --- ç¯å¢ƒè®¾ç½® ---
        const plane = new THREE.Mesh(
            new THREE.CircleGeometry(20, 64),
            new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8, metalness: 0.3 })
        );
        plane.rotation.x = -Math.PI / 2; plane.position.y = -2; plane.receiveShadow = true;
        scene.add(plane);

        scene.add(new THREE.AmbientLight(0xffffff, 0.1));
        const spotLight = new THREE.SpotLight(0xffeebb, 100);
        spotLight.position.set(10, 20, 10); spotLight.castShadow = true;
        scene.add(spotLight);
        scene.add(new THREE.PointLight(0x4444ff, 50, 20).translateX(-5).translateY(5).translateZ(-5));

        // --- é›ªèŠ± ---
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 4000;
        const posArray = new Float32Array(snowCount * 3);
        const velArray = [];
        for(let i=0; i<snowCount * 3; i+=3) {
            posArray[i] = (Math.random() - 0.5) * 50;
            posArray[i+1] = Math.random() * 20;
            posArray[i+2] = (Math.random() - 0.5) * 50;
            velArray.push((Math.random() * 0.05) + 0.02);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
        const snowMesh = new THREE.Points(snowGeo, new THREE.PointsMaterial({
            size: 0.08, color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending
        }));
        scene.add(snowMesh);

        // --- éŸ³ä¹ ---
        const musicBtn = document.getElementById('music-btn');
        const bgm = document.getElementById('bgm');
        let isPlaying = false;
        musicBtn.addEventListener('click', () => {
            if (isPlaying) { bgm.pause(); musicBtn.textContent = "ğŸµ Play Music"; musicBtn.style.color = "white"; } 
            else { bgm.play().then(() => { musicBtn.textContent = "ğŸµ Pause"; musicBtn.style.color = "#ffd700"; }); }
            isPlaying = !isPlaying;
        });

        // --- åŠ¨ç”» ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            controls.update();

            const time = Date.now() * 0.002;
            const elapsedTime = clock.getElapsedTime();

            // é›ªèŠ±
            const positions = snowGeo.attributes.position.array;
            for(let i=1; i<snowCount*3; i+=3) {
                positions[i] -= velArray[(i-1)/3];
                if (positions[i] < -2) positions[i] = 20;
            }
            snowGeo.attributes.position.needsUpdate = true;

            // æ˜Ÿæ˜Ÿé—ªçƒ
            treeObj.star.rotation.y = time * 0.5;
            treeObj.star.scale.setScalar(1 + Math.sin(time*2) * 0.1);

            // åœ£è¯è€äººé£è¡Œè½¨è¿¹ (åœ¨å¤©ç©ºä¸­ç›˜æ—‹)
            const flyRadius = 10;
            const flyHeight = 8;
            const flySpeed = 0.3;
            
            santaObj.position.x = Math.sin(elapsedTime * flySpeed) * flyRadius;
            santaObj.position.z = Math.cos(elapsedTime * flySpeed) * flyRadius;
            santaObj.position.y = flyHeight + Math.sin(elapsedTime * 1) * 1.5; // ä¸Šä¸‹èµ·ä¼
            
            // è®©è½¦å¤´å§‹ç»ˆæœå‘é£è¡Œæ–¹å‘
            santaObj.lookAt(
                Math.sin(elapsedTime * flySpeed + 0.1) * flyRadius, 
                flyHeight + Math.sin((elapsedTime + 0.1) * 1) * 1.5, 
                Math.cos(elapsedTime * flySpeed + 0.1) * flyRadius
            );

            composer.render();
        }

        setTimeout(() => { document.getElementById('loader').style.opacity = '0'; setTimeout(() => document.getElementById('loader').style.display = 'none', 1000); }, 1500);
        animate();
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
